const std = @import("std");
const config = @import("config");
const svd = @import("svd");

const port = @import("port.zig");
const Pin = @import("Pin.zig");

pub const DeadlineFn = fn () bool;

pub const Config = struct {
    baud_rate: ?BaudRate = null,
    /// I2C pins. If not provided, default pins will be used.
    pins: ?Pins = null,
};

pub const DutyCycle = enum {
    @"2",
    @"16/9",
};

pub const BaudRate = struct {
    /// Peripheral clock in Hz.
    peripheral_clock: u32,
    /// Speed in Hz. Must be less than or equal to 400 kHz.
    speed: u32,
    /// Duty cycle for fast mode(>100 kHz).
    /// Ignored for standard mode.
    duty_cycle: DutyCycle = .@"2",
};

pub const Address = union(enum) {
    seven_bit: u7,
    ten_bit: u10,

    pub fn from7(value: u7) Address {
        return .{ .seven_bit = value };
    }

    pub fn from10(value: u10) Address {
        return .{ .ten_bit = value };
    }
};

pub const Pins = switch (config.chip_series) {
    .ch32v003 => @import("i2c/ch32v003.zig").Pins,
    // .ch32v30x => @import("i2c/ch32v30x.zig").Pins,
    // TODO: implement other chips
    else => @compileError("Unsupported chip series"),
};

const rcc = switch (config.chip_series) {
    .ch32v003 => @import("i2c/ch32v003.zig").rcc,
    // .ch32v30x => @import("i2c/ch32v30x.zig").rcc,
    // TODO: implement other chips
    else => @compileError("Unsupported chip series"),
};

pub const Error = error{
    /// Bus error (BERR).
    Bus,
    /// Acknowledge Failure (AF).
    AckFailure,
    /// Arbitration Lost (ARLO).
    ArbitrationLost,
    /// Overrun/underrun Error (OVR).
    Overrun,
    /// Packet Error Checksum (PECERR).
    PacketCheck,
    /// Timeout error. Generated by the HAL.
    Timeout,
};

const I2C = @This();

reg: *volatile svd.types.I2C,

pub fn init(i2c: svd.peripherals.I2C, comptime cfg: Config) I2C {
    const self = I2C{ .reg = i2c.get() };

    self.reset();
    self.enable();
    self.configurePins(cfg);
    if (cfg.baud_rate) |baud_rate| {
        self.configureBaudRate(baud_rate);
    }
    self.configureCtrl(cfg);

    return self;
}

/// Deinitializes the I2C peripheral.
/// Disables and resets registers.
/// Note: GPIO pins will not be deinitialized when this function is called.
pub fn deinit(self: I2C) void {
    self.disable();
    self.reset();
}

fn configurePins(self: I2C, comptime cfg: Config) void {
    const pins = cfg.pins orelse Pins.get_default(self.reg);

    if (pins.remap.has()) {
        // Alternate function I/O clock enable
        svd.peripherals.RCC.APB2PCENR.modify(.{ .AFIOEN = 1 });
        // Remap the pins.
        svd.peripherals.AFIO.PCFR1.modify(pins.remap.afio_pcfr1);
        if (config.chip_series != .ch32v003) {
            svd.peripherals.AFIO.PCFR2.modify(pins.remap.afio_pcfr2);
        }
    }

    port.enable(pins.scl.port);
    pins.scl.asOutput(.{ .speed = .max_50mhz, .mode = .alt_open_drain });
    port.enable(pins.sda.port);
    pins.sda.asOutput(.{ .speed = .max_50mhz, .mode = .alt_open_drain });
}

/// Runtime baud rate configuration.
pub fn configureBaudRate(self: I2C, baud_rate: BaudRate) !void {
    if (baud_rate.peripheral_clock == 0 or baud_rate.speed == 0 or baud_rate.speed > 400_000) {
        return error.InvalidBaudRate;
    }

    self.reg.CTLR2.modify(.{ .FREQ = @truncate(baud_rate.peripheral_clock / 1_000_000) });

    const is_standard_mode = baud_rate.speed <= 100_000;
    const ccr = if (is_standard_mode) blk: {
        const result = baud_rate.peripheral_clock / (baud_rate.speed * 2);
        break :blk @max(result, 4);
    } else blk: {
        const result = switch (baud_rate.duty_cycle) {
            .@"2" => baud_rate.peripheral_clock / (baud_rate.speed * 3),
            .@"16/9" => baud_rate.peripheral_clock / (baud_rate.speed * 25),
        };

        break :blk @max(result, 1);
    };
    self.reg.CKCFGR.write(.{
        .CCR = @truncate(ccr),
        .DUTY = if (baud_rate.duty_cycle == .@"2") 0 else 1,
        .F_S = if (is_standard_mode) 0 else 1,
    });
}

fn configureCtrl(self: I2C, comptime cfg: Config) void {
    // PE: Peripheral enable
    self.reg.CTLR1.write(.{ .PE = 1 });

    _ = cfg;
    // FIXME slave mode.
    // if (cfg.ack) |ack| {
    //     self.reg.CTLR1.modify(.{ .ACK = 1 });
    //
    //     if (ack.own_address1) |own_address1| {
    //         switch (own_address1) {
    //             .seven_bit => |addr| {
    //                 self.reg.OADDR1.write(.{ .ADD7_1 = addr });
    //             },
    //             .ten_bit => |addr| {
    //                 self.reg.OADDR1.write(.{
    //                     .ADDMODE = 1,
    //                     .ADD0 = @truncate(addr),
    //                     .ADD7_1 = @truncate(addr >> 1),
    //                     .ADD9_8 = @truncate(addr >> 8),
    //                 });
    //             },
    //         }
    //     }
    // }
}

pub fn enable(self: I2C) void {
    rcc.enable(self.reg);
}

pub fn disable(self: I2C) void {
    rcc.disable(self.reg);
}

fn reset(self: I2C) void {
    rcc.reset(self.reg);
}

fn isNotBusy(self: I2C) bool {
    return self.reg.STAR2.read().BUSY == 0;
}

fn isReadable(self: I2C) bool {
    return self.reg.STAR1.read().RxNE == 1;
}

fn isWriteable(self: I2C) bool {
    return self.reg.STAR1.read().TxE == 1;
}

const Event = enum(u32) {
    // I2C Master Events.

    // Start communicate.

    master_mode_select = 0x00030001, // BUSY, MSL and SB flag (EVT5)

    // Address Acknowledge.

    master_transmitter_mode_selected = 0x00070082, // BUSY, MSL, ADDR, TXE and TRA flags (EVT6)
    master_receiver_mode_selected = 0x00030002, // BUSY, MSL and ADDR flags (EVT6)
    master_mode_address10 = 0x00030008, // BUSY, MSL and ADD10 flags (EVT9)

    // Communication events.

    master_byte_received = 0x00030040, // BUSY, MSL and RXNE flags (EVT7)
    master_byte_transmitting = 0x00070080, // TRA, BUSY, MSL and TXE flags (EVT8)
    master_byte_transmitted = 0x00070084, // TRA, BUSY, MSL, TXE and BTF flags (EVT8_2)

    // I2C Slave Events.

    // Start Communicate events

    slave_reveiver_address_matched = 0x00020002, // BUSY and ADDR flags  (EVT1)
    slave_transmitter_address_matched = 0x00060082, // TRA, BUSY, TXE and ADDR flags
    slave_reveiver_second_address_matched = 0x00820000, // DUALF and BUSY flags
    slave_transmitter_second_address_matched = 0x00860080, // DUALF, TRA, BUSY and TXE flags
    slave_general_call_address_matched = 0x00120000, // GENCALL and BUSY flags

    // Communication events.

    slave_byte_received = 0x00020040, // BUSY and RXNE flags (EVT2)
    slave_stop_detected = 0x00000010, // STOPF flag (EVT4)
    slave_byte_transmitted = 0x00060084, // TRA, BUSY, TXE and BTF flags (EVT3)
    slave_byte_transmitting = 0x00060080, // TRA, BUSY and TXE flags (EVT3)
    slave_ack_failure = 0x00000400, // AF flag (EVT3_2)
};

fn checkEvent(self: I2C, event: Event) bool {
    // Order of reading the status registers is important!
    // First read STAR1 and then STAR2.
    const s1 = self.reg.STAR1;
    // Prevent compiler reordering of reads.
    asm volatile ("" ::: "memory");
    const s2 = self.reg.STAR2;

    const s1_raw: u16 = @truncate(s1.raw);
    const s2_raw: u16 = @truncate(s2.raw);

    const status: u32 = (@as(u32, s2_raw) << 16) | s1_raw;
    const last_event = status & 0x00FFFFFF;
    const has_event = last_event & @intFromEnum(event) == @intFromEnum(event);
    if (has_event) {
        return true;
    }

    return false;
}

fn checkErrors(self: I2C) Error!void {
    const star1 = self.reg.STAR1.read();

    // TODO: for 30x check s1_reg.TIMEOUT
    // if (STAR1_reg.TIMEOUT == 1) {
    //    STAR1.modify(.{ .TIMEOUT = 0 });
    //    return error.Timeout;
    // }
    if (star1.PECERR == 1) {
        self.reg.STAR1.modify(.{ .PECERR = 0 });
        return error.PacketCheck;
    }
    if (star1.OVR == 1) {
        self.reg.STAR1.modify(.{ .OVR = 0 });
        return error.Overrun;
    }
    if (star1.ARLO == 1) {
        self.reg.STAR1.modify(.{ .ARLO = 0 });
        return error.ArbitrationLost;
    }
    if (star1.AF == 1) {
        self.reg.STAR1.modify(.{ .AF = 0 });
        return error.AckFailure;
    }
    if (star1.BERR == 1) {
        self.reg.STAR1.modify(.{ .BERR = 0 });
        return error.Bus;
    }
}

pub const Direction = enum(u1) {
    transmitter = 0,
    receiver = 1,
};

fn sendAddressAndWaitModeSelectedEvent(self: I2C, address: Address, direction: Direction, deadlineFn: ?DeadlineFn) !void {
    // In 7-bit address mode, the first byte sent is the address byte, the first 7 bits represent the address of the target
    // slave device, the 8th bit determines the direction of the subsequent message, 0 means the master device writes
    // data to the slave device, 1 means the master device reads information to the slave device.
    // In 10-bit address mode, as shown in Figure 13-3, in the send address phase, the first byte is 11110xx0, xx is
    // the highest 2 bits of the 10-bit address, and the second byte is the lower 8 bits of the 10-bit address. If
    // subsequently enter the master device transmit mode, continue to send data; if subsequently ready to enter the
    // master device receive mode, you need to re-send a start condition, follow to send a byte as 11110xx1, and then
    // enter the master device receive mode.

    const event = switch (direction) {
        .transmitter => Event.master_transmitter_mode_selected,
        .receiver => Event.master_receiver_mode_selected,
    };

    switch (address) {
        .seven_bit => |addr| {
            self.reg.DATAR.raw = @as(u8, addr) << 1 | @intFromEnum(direction);
            try self.waitEvent(event, deadlineFn);
        },
        .ten_bit => |addr| {
            // Write frame header
            const upper_2_bits = addr >> 8;
            self.reg.DATAR.raw = 0xF0 | upper_2_bits << 1 | @intFromEnum(Direction.transmitter);

            try self.waitEvent(.master_mode_address10, deadlineFn);

            // Write 8-bit address
            self.reg.DATAR.raw = @as(u8, @truncate(addr));

            try self.waitEvent(.master_transmitter_mode_selected, deadlineFn);

            // Write the repeated start condition.
            if (direction == Direction.receiver) {
                // Repeat start condition.
                self.reg.CTLR1.modify(.{ .START = 1 });
                try self.waitEvent(.master_mode_select, deadlineFn);

                self.reg.DATAR.raw = 0xF0 | upper_2_bits << 1 | @intFromEnum(Direction.receiver);

                try self.waitEvent(event, deadlineFn);
            }
        },
    }
}

pub fn masterTransferBlocking(self: I2C, address: Address, send: []const u8, recv: ?[]u8, deadlineFn: ?DeadlineFn) Error!void {
    const recv_vec: ?[]const []u8 = if (recv) |r| &.{r} else null;
    return self.masterTransferVecBlocking(address, &.{send}, recv_vec, deadlineFn);
}

pub fn masterTransferVecBlocking(self: I2C, address: Address, send: []const []const u8, recv: ?[]const []u8, deadlineFn: ?DeadlineFn) Error!void {
    try self.wait(isNotBusy, deadlineFn);

    self.reg.CTLR1.modify(.{ .START = 1 });
    defer self.reg.CTLR1.modify(.{ .STOP = 1 });

    try self.waitEvent(.master_mode_select, deadlineFn);

    try self.writeVecBlockingInternal(address, send, deadlineFn);

    if (recv) |buffers| {
        // Repeat start condition.
        self.reg.CTLR1.modify(.{ .START = 1, .ACK = 1 });
        try self.waitEvent(.master_mode_select, deadlineFn);

        try self.readVecBlockingInternal(address, buffers, deadlineFn);
    }
}

fn writeVecBlockingInternal(self: I2C, address: Address, payloads: []const []const u8, deadlineFn: ?DeadlineFn) Error!void {
    try self.sendAddressAndWaitModeSelectedEvent(address, .transmitter, deadlineFn);

    for (payloads) |payload| {
        for (payload) |b| {
            try self.wait(isWriteable, deadlineFn);

            self.reg.DATAR.raw = b;
        }
    }

    try self.waitEvent(.master_byte_transmitted, deadlineFn);
}

fn readVecBlockingInternal(self: I2C, address: Address, buffers: []const []u8, deadlineFn: ?DeadlineFn) Error!void {
    try self.sendAddressAndWaitModeSelectedEvent(address, .receiver, deadlineFn);

    for (buffers) |buffer| {
        for (buffer, 0..) |*byte, i| {
            if (i == buffer.len - 1) {
                // Return NACK on the last byte.
                self.reg.CTLR1.modify(.{ .ACK = 0 });
            }

            try self.wait(isReadable, deadlineFn);

            byte.* = @truncate(self.reg.DATAR.raw);
        }
    }
}

fn waitEvent(self: I2C, event: Event, deadlineFn: ?DeadlineFn) Error!void {
    while (!self.checkEvent(event)) {
        try self.checkErrors();

        if (deadlineFn) |check| {
            if (check()) {
                return error.Timeout;
            }
        }
        asm volatile ("" ::: "memory");
    }
}

// Wait for a condition to be true.
fn wait(self: I2C, conditionFn: fn (self: I2C) bool, deadlineFn: ?DeadlineFn) Error!void {
    while (!conditionFn(self)) {
        try self.checkErrors();

        if (deadlineFn) |check| {
            if (check()) {
                return error.Timeout;
            }
        }
        asm volatile ("" ::: "memory");
    }
}
