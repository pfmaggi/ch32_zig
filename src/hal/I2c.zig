const std = @import("std");
const config = @import("config");
const svd = @import("svd");

const time = @import("time.zig");
const Pin = @import("Pin.zig");

pub const Config = struct {
    mode: Mode = .master,
    baud_rate: ?BaudRate = null,
    /// I2C pins. If not provided, default pins will be used.
    pins: ?Pins = null,
};

pub const Mode = union(enum) {
    master: void,
    slave: ModeSlave,
};

pub const ModeSlave = struct {
    /// Own address 1.
    own_address1: ?Address = null,
    /// Own address 2.
    own_address2: ?Address = null,
};

pub const DutyCycle = enum {
    @"2",
    @"16/9",
};

pub const BaudRate = struct {
    /// Peripheral clock in Hz.
    peripheral_clock: u32,
    /// Speed in Hz. Must be less than or equal to 400 kHz.
    speed: u32,
    /// Duty cycle for fast mode(>100 kHz).
    /// Ignored for standard mode.
    duty_cycle: DutyCycle = .@"2",

    pub fn isValid(self: BaudRate) bool {
        return self.peripheral_clock > 0 and self.speed > 0 and self.speed <= 400_000;
    }
};

pub const Address = union(enum) {
    seven_bit: u7,
    ten_bit: u10,

    pub fn from7(value: u7) Address {
        return .{ .seven_bit = value };
    }

    pub fn from10(value: u10) Address {
        return .{ .ten_bit = value };
    }
};

const chip = switch (config.chip.series) {
    .ch32v003 => @import("i2c/ch32v003.zig"),
    // .ch32v30x => @import("i2c/ch32v30x.zig"),
    // TODO: implement other chips
    else => @compileError("Unsupported chip series"),
};

pub const Pins = chip.Pins;

const rcc = chip.rcc;

pub const Error = error{
    /// Bus error (BERR).
    Bus,
    /// Acknowledge Failure (AF).
    AckFailure,
    /// Arbitration Lost (ARLO).
    ArbitrationLost,
    /// Overrun/underrun Error (OVR).
    Overrun,
    /// Packet Error Checksum (PECERR).
    PacketCheck,
    /// Timeout error. Generated by the HAL.
    Timeout,
};

pub const BaudRateError = error{
    /// Invalid baud rate.
    InvalidBaudRate,
};

const I2C = @This();

reg: *volatile svd.registers.I2C,

pub fn init(comptime i2c: svd.peripherals.I2C, comptime cfg: Config) I2C {
    const self = I2C{ .reg = i2c.get() };

    self.reset();
    self.enable();
    self.configurePins(cfg);
    if (cfg.baud_rate) |baud_rate| {
        comptime if (!baud_rate.isValid()) {
            @compileError("Invalid baud rate configuration");
        };
        self.configureBaudRate(baud_rate) catch unreachable;
    }
    self.configureCtrl(cfg);

    return self;
}

/// Deinitializes the I2C peripheral.
/// Disables and resets registers.
/// Note: GPIO pins will not be deinitialized when this function is called.
pub fn deinit(self: I2C) void {
    self.disable();
    self.reset();
}

fn configurePins(comptime self: I2C, comptime cfg: Config) void {
    if (cfg.pins) |pins| {
        comptime checkPins(self.reg, pins);
    }

    const pins = cfg.pins orelse Pins.defaultFor(self.reg);

    if (pins.remap.has()) {
        // Alternate function I/O clock enable
        svd.peripherals.RCC.APB2PCENR.modify(.{ .AFIOEN = 1 });
        // Remap the pins.
        svd.peripherals.AFIO.PCFR1.modify(pins.remap.afio_pcfr1);
        if (config.chip.series != .ch32v003) {
            svd.peripherals.AFIO.PCFR2.modify(pins.remap.afio_pcfr2);
        }
    }

    pins.scl.enablePort();
    pins.scl.asOutput(.{ .speed = .max_50mhz, .mode = .alt_open_drain });
    pins.sda.enablePort();
    pins.sda.asOutput(.{ .speed = .max_50mhz, .mode = .alt_open_drain });
}

/// Runtime baud rate configuration.
pub fn configureBaudRate(self: I2C, baud_rate: BaudRate) BaudRateError!void {
    if (!baud_rate.isValid()) {
        return error.InvalidBaudRate;
    }

    const freq = baud_rate.peripheral_clock / 1_000_000;
    self.reg.CTLR2.modify(.{ .FREQ = @truncate(freq) });

    const is_standard_mode = baud_rate.speed <= 100_000;
    const ccr = if (is_standard_mode) blk: {
        const result = baud_rate.peripheral_clock / (baud_rate.speed * 2);
        break :blk @max(result, 4);
    } else blk: {
        const result = switch (baud_rate.duty_cycle) {
            .@"2" => baud_rate.peripheral_clock / (baud_rate.speed * 3),
            .@"16/9" => baud_rate.peripheral_clock / (baud_rate.speed * 25),
        };

        break :blk @max(result, 1);
    };

    if (config.chip.series != .ch32v003) {
        const trise = if (is_standard_mode) freq + 1 else freq * 300 / 1000 + 1;
        self.reg.RTR.modify(.{ .TRISE = @truncate(trise) });
    }
    self.reg.CKCFGR.write(.{
        .CCR = @truncate(ccr),
        .DUTY = if (baud_rate.duty_cycle == .@"2") 0 else 1,
        .F_S = if (is_standard_mode) 0 else 1,
    });
}

fn configureCtrl(self: I2C, comptime cfg: Config) void {
    switch (cfg.mode) {
        .master => {
            // PE: Peripheral enable
            self.reg.CTLR1.write(.{ .PE = 1 });
        },
        .slave => |slave| {
            if (slave.own_address1) |own_addr| {
                switch (own_addr) {
                    .seven_bit => |addr| {
                        self.reg.OADDR1.write(.{ .ADD7_1 = addr });
                    },
                    .ten_bit => |addr| {
                        self.reg.OADDR1.write(.{
                            .ADDMODE = 1,
                            .ADD0 = @truncate(addr),
                            .ADD7_1 = @truncate(addr >> 1),
                            .ADD9_8 = @truncate(addr >> 8),
                        });
                    },
                }
            }

            if (slave.own_address2) |own_addr| {
                switch (own_addr) {
                    .seven_bit => |addr| {
                        self.reg.OADDR2.write(.{
                            // Dual address mode enable bit, set this bit to allow
                            // ADD2 to be recognized as well.
                            .ENDUAL = 1,
                            .ADD2 = addr,
                        });
                    },
                    .ten_bit => @compileError("I2C slave address 2 must be 7-bit address."),
                }
            }

            // PE: Peripheral enable
            self.reg.CTLR1.write(.{ .PE = 1 });

            // ACK: Acknowledge enable
            self.reg.CTLR1.modify(.{ .ACK = 1 });
        },
    }
}

pub fn enable(self: I2C) void {
    rcc.enable(self.reg);
}

pub fn disable(self: I2C) void {
    rcc.disable(self.reg);
}

fn reset(self: I2C) void {
    rcc.reset(self.reg);

    // Software reset.
    self.reg.CTLR1.modify(.{ .SWRST = 1 });
    self.reg.CTLR1.modify(.{ .SWRST = 0 });
}

/// Master transfer with blocking.
///
/// Null send buffer allowed for scan devices.
/// If device is present, it will ACK and no error will be returned.
/// Otherwise, NACK will be received and AckFailure error will be returned.
pub fn masterTransferBlocking(self: I2C, address: Address, send: ?[]const u8, recv: ?[]u8, deadline: time.Deadline) Error!void {
    const send_vec: ?[]const []const u8 = if (send) |s| &.{s} else null;
    const recv_vec: ?[]const []u8 = if (recv) |r| &.{r} else null;
    return self.masterTransferVecBlocking(address, send_vec, recv_vec, deadline);
}

/// Master transfer with blocking. See `masterTransferBlocking` for more details.
/// This function the same as `masterTransferBlocking` but allows to send multiple payloads.
pub fn masterTransferVecBlocking(self: I2C, address: Address, send: ?[]const []const u8, recv: ?[]const []u8, deadline: time.Deadline) Error!void {
    try self.waitEventNot(.is_busy, deadline);

    self.reg.CTLR1.modify(.{ .START = 1 });
    defer self.reg.CTLR1.modify(.{ .STOP = 1 });

    try self.waitEvent(.master_mode_select, deadline);

    try self.masterWriteVecBlockingInternal(address, send, deadline);

    if (recv) |buffers| {
        // Repeat start condition.
        self.reg.CTLR1.modify(.{ .START = 1, .ACK = 1 });
        try self.waitEvent(.master_mode_select, deadline);

        try self.masterReadVecBlockingInternal(address, buffers, deadline);
    }
}

pub fn slaveAddressMatchingBlocking(self: I2C, deadline: time.Deadline) Error!Direction {
    while (true) {
        const status = self.getStatus();
        if (status.hasEvent(.slave_transmitter_address_matched)) return .transmit;
        if (status.hasEvent(.slave_reveiver_address_matched)) return .receive;

        try self.checkErrors(status.toStar1());

        if (deadline.isReached()) {
            return error.Timeout;
        }
        asm volatile ("" ::: .{ .memory = true });
    }
}

pub fn slaveReadBlocking(self: I2C, buffer: []u8, deadline: time.Deadline) Error!usize {
    return self.slaveReadVecBlocking(&.{buffer}, deadline);
}

pub fn slaveReadVecBlocking(self: I2C, buffers: []const []u8, deadline: time.Deadline) Error!usize {
    var total: usize = 0;

    for (buffers) |buffer| buffers: {
        for (buffer) |*byte| {
            while (true) {
                const STAR1 = self.reg.STAR1.read();

                // Is readable.
                if (STAR1.RxNE == 1) break;

                if (STAR1.STOPF == 1 or STAR1.ADDR == 1) break :buffers;

                self.checkErrors(STAR1) catch |err| switch (err) {
                    error.AckFailure => break :buffers,
                    else => return err,
                };

                if (deadline.isReached()) {
                    return error.Timeout;
                }
                asm volatile ("" ::: .{ .memory = true });
            }

            byte.* = @truncate(self.reg.DATAR.raw);
            total += 1;
        }
    }

    while (true) {
        const STAR1 = self.reg.STAR1.read();

        // Need to keep reading as long as the master send data,
        // otherwise, the system may hang in an undefined state.
        if (STAR1.RxNE == 0) {
            break;
        }
        self.reg.DATAR.raw = 0;
    }

    return total;
}

pub fn slaveWriteBlocking(self: I2C, send: []const u8, deadline: time.Deadline) Error!usize {
    return self.slaveWriteVecBlocking(&.{send}, deadline);
}

pub fn slaveWriteVecBlocking(self: I2C, payloads: []const []const u8, deadline: time.Deadline) Error!usize {
    var total: usize = 0;

    for (payloads) |payload| payloads: {
        for (payload) |b| {
            while (true) {
                const STAR1 = self.reg.STAR1.read();

                // Is writable.
                if (STAR1.TxE == 1) break;

                if (STAR1.STOPF == 1 or STAR1.ADDR == 1 or STAR1.AF == 1) break :payloads;

                try self.checkErrors(STAR1);

                if (deadline.isReached()) {
                    return error.Timeout;
                }
                asm volatile ("" ::: .{ .memory = true });
            }

            self.reg.DATAR.raw = b;
            total += 1;
        }
    }

    while (true) {
        const STAR1 = self.reg.STAR1.read();

        // Need to keep writing as long as the master requests data,
        // otherwise, the system may hang in an undefined state.
        if (STAR1.TxE == 1) {
            self.reg.DATAR.raw = 0;
        }

        // Wait NAck
        if (STAR1.AF == 1) break;
    }

    // Clear NAck
    self.reg.STAR1.modify(.{ .AF = 0 });

    return total;
}

fn masterWriteVecBlockingInternal(self: I2C, address: Address, send: ?[]const []const u8, deadline: time.Deadline) Error!void {
    try self.sendAddressAndWaitModeSelectedEvent(address, .transmit, deadline);

    const payloads = send orelse return;

    var is_sent = false;
    for (payloads) |payload| {
        for (payload) |b| {
            try self.waitEvent(.is_writable, deadline);

            self.reg.DATAR.raw = b;
        }

        if (!is_sent and payload.len > 0) is_sent = true;
    }

    // If no data was sent, return without waiting for the event.
    if (!is_sent) return;

    try self.waitEvent(.master_byte_transmitted, deadline);
}

fn masterReadVecBlockingInternal(self: I2C, address: Address, buffers: []const []u8, deadline: time.Deadline) Error!void {
    try self.sendAddressAndWaitModeSelectedEvent(address, .receive, deadline);

    for (buffers) |buffer| {
        for (buffer, 0..) |*byte, i| {
            if (i == buffer.len - 1) {
                // Return NACK on the last byte.
                self.reg.CTLR1.modify(.{ .ACK = 0 });
            }

            try self.waitEvent(.is_readable, deadline);

            byte.* = @truncate(self.reg.DATAR.raw);
        }
    }
}

const Direction = enum(u1) {
    transmit = 0,
    receive = 1,
};

fn sendAddressAndWaitModeSelectedEvent(self: I2C, address: Address, direction: Direction, deadline: time.Deadline) !void {
    // In 7-bit address mode, the first byte sent is the address byte, the first 7 bits represent the address of the target
    // slave device, the 8th bit determines the direction of the subsequent message, 0 means the master device writes
    // data to the slave device, 1 means the master device reads information to the slave device.
    // In 10-bit address mode, as shown in Figure 13-3, in the send address phase, the first byte is 11110xx0, xx is
    // the highest 2 bits of the 10-bit address, and the second byte is the lower 8 bits of the 10-bit address. If
    // subsequently enter the master device transmit mode, continue to send data; if subsequently ready to enter the
    // master device receive mode, you need to re-send a start condition, follow to send a byte as 11110xx1, and then
    // enter the master device receive mode.

    const event = switch (direction) {
        .transmit => Event.master_transmitter_mode_selected,
        .receive => Event.master_receiver_mode_selected,
    };

    switch (address) {
        .seven_bit => |addr| {
            self.reg.DATAR.raw = @as(u8, addr) << 1 | @intFromEnum(direction);
            try self.waitEvent(event, deadline);
        },
        .ten_bit => |addr| {
            // Write frame header
            const upper_2_bits = addr >> 8;
            self.reg.DATAR.raw = 0xF0 | upper_2_bits << 1 | @intFromEnum(Direction.transmit);

            try self.waitEvent(.master_mode_address10, deadline);

            // Write 8-bit address
            self.reg.DATAR.raw = @as(u8, @truncate(addr));

            try self.waitEvent(.master_transmitter_mode_selected, deadline);

            // Write the repeated start condition.
            if (direction == Direction.receive) {
                // Repeat start condition.
                self.reg.CTLR1.modify(.{ .START = 1 });
                try self.waitEvent(.master_mode_select, deadline);

                self.reg.DATAR.raw = 0xF0 | upper_2_bits << 1 | @intFromEnum(Direction.receive);

                try self.waitEvent(event, deadline);
            }
        },
    }
}

pub const Event = enum(u32) {
    // I2C Master Events.

    // Start communicate.

    master_mode_select = BUSY | MSL | SB, // EVT5

    // Address Acknowledge.

    master_transmitter_mode_selected = BUSY | MSL | ADDR | TxE | TRA, // EVT6
    master_receiver_mode_selected = BUSY | MSL | ADDR, // EVT6
    master_mode_address10 = BUSY | MSL | ADD10, // EVT9

    // Communication events.

    master_byte_received = BUSY | MSL | RxNE, // EVT7
    master_byte_transmitting = TRA | BUSY | MSL | TxE, // EVT8
    master_byte_transmitted = TRA | BUSY | MSL | TxE | BTF, // EVT8_2

    // I2C Slave Events.

    // Start Communicate events

    slave_reveiver_address_matched = BUSY | ADDR, // EVT1
    slave_transmitter_address_matched = TRA | BUSY | TxE | ADDR, // EVT1
    slave_reveiver_second_address_matched = DUALF | BUSY, // EVT1
    slave_transmitter_second_address_matched = DUALF | TRA | BUSY | TxE, // EVT1
    slave_general_call_address_matched = GENCALL | BUSY, // EVT1

    // Communication events.

    slave_byte_received = BUSY | RxNE, // EVT2
    slave_stop_detected = STOPF, // EVT4
    slave_byte_transmitted = TRA | BUSY | TxE | BTF, // EVT3
    slave_byte_transmitting = TRA | BUSY | TxE, // EVT3
    slave_ack_failure = AF, // EVT3_2

    // Common Events.

    is_busy = BUSY,
    is_writable = TxE,
    is_readable = RxNE,

    _,

    const SB = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR1, "SB");
    const ADDR = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR1, "ADDR");
    const BTF = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR1, "BTF");
    const ADD10 = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR1, "ADD10");
    const STOPF = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR1, "STOPF");
    const RxNE = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR1, "RxNE");
    const TxE = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR1, "TxE");
    const AF = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR1, "AF");

    const MSL = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR2, "MSL") + 16;
    const BUSY = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR2, "BUSY") + 16;
    const TRA = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR2, "TRA") + 16;
    const GENCALL = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR2, "GENCALL") + 16;
    const SMBDEFAULT = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR2, "SMBDEFAULT") + 16;
    const SMBHOST = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR2, "SMBHOST") + 16;
    const DUALF = @as(u32, 1) << @bitOffsetOf(svd.types.I2C.STAR2, "DUALF") + 16;

    pub fn from(v: u32) Event {
        return @enumFromInt(v);
    }
};

pub const Status = enum(u32) {
    _,

    pub fn hasEvent(self: Status, event: Event) bool {
        return @intFromEnum(self) & @intFromEnum(event) == @intFromEnum(event);
    }

    inline fn toStar1(self: Status) svd.types.I2C.STAR1 {
        return @bitCast(@intFromEnum(self));
    }

    inline fn toStar2(self: Status) svd.types.I2C.STAR2 {
        return @bitCast(@intFromEnum(self) >> 16);
    }
};

pub fn getStatus(self: I2C) Status {
    // Order of reading the status registers is important!
    // First read STAR1 and then STAR2.
    const s1 = self.reg.STAR1;
    // Prevent compiler reordering of reads.
    asm volatile ("" ::: .{ .memory = true });
    const s2 = self.reg.STAR2;

    const s1_raw: u16 = @truncate(s1.raw);
    const s2_raw: u16 = @truncate(s2.raw);

    const status: u32 = (@as(u32, s2_raw) << 16) | s1_raw;
    const last_event = status & 0x00FFFFFF;

    return @enumFromInt(last_event);
}

fn checkErrors(i2c: I2C, star1: svd.types.I2C.STAR1) Error!void {
    if (config.chip.series != .ch32v003) {
        if (star1.TIMEOUT == 1) {
            i2c.reg.STAR1.modify(.{ .TIMEOUT = 0 });
            return error.Timeout;
        }
    }
    if (star1.PECERR == 1) {
        i2c.reg.STAR1.modify(.{ .PECERR = 0 });
        return error.PacketCheck;
    }
    if (star1.OVR == 1) {
        i2c.reg.STAR1.modify(.{ .OVR = 0 });
        return error.Overrun;
    }
    if (star1.ARLO == 1) {
        i2c.reg.STAR1.modify(.{ .ARLO = 0 });
        return error.ArbitrationLost;
    }
    if (star1.AF == 1) {
        i2c.reg.STAR1.modify(.{ .AF = 0 });
        return error.AckFailure;
    }
    if (star1.BERR == 1) {
        i2c.reg.STAR1.modify(.{ .BERR = 0 });
        return error.Bus;
    }
}

fn waitEvent(self: I2C, event: Event, deadline: time.Deadline) Error!void {
    return self.waitEventState(event, true, deadline);
}

fn waitEventNot(self: I2C, event: Event, deadline: time.Deadline) Error!void {
    return self.waitEventState(event, false, deadline);
}

fn waitEventState(self: I2C, event: Event, state: bool, deadline: time.Deadline) Error!void {
    while (true) {
        const status = self.getStatus();
        if (status.hasEvent(event) == state) {
            return;
        }

        try self.checkErrors(status.toStar1());

        if (deadline.isReached()) {
            return error.Timeout;
        }
        asm volatile ("" ::: .{ .memory = true });
    }
}

// Comptime pins checks.
fn checkPins(comptime reg: *volatile svd.registers.I2C, comptime pins: Pins) void {
    const pins_namespace = Pins.namespaceFor(reg);

    // Find pins from namespace.
    var periph_pins_maybe: ?Pins = null;
    for (@typeInfo(pins_namespace).@"struct".decls) |decl| {
        const p_pins: Pins = @field(pins_namespace, decl.name);
        if (p_pins.eq(pins)) {
            periph_pins_maybe = p_pins;
            break;
        }
    }
    _ = periph_pins_maybe orelse @compileError(
        \\Pins not found in namespace for selected I2C.
        \\This may be due to an incorrect pin configuration.
        \\For example, if you are using I2C1, the pins should be from Pins.i2c1 namespace.
    );
}
